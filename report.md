# Лабораторная работа 5 (№7 по методичке)

## Исследование рекуррентной нейронной сети Хопфилда на примере задачи распознавания образов

### Цель
Исследовать процедуры обучения и функционирования рекуррентной нейронной сети (РНС) Хопфилда в качестве устройства автоассоциативной памяти.

### Данные
Режим работы: *Синхронный*  
Запоминаемые образы: *248*  

### Закодированные эталонные образы (паттерны)
```python
"""
 1  1  1
-1 -1  1
 1  1  1
 1 -1 -1
 1  1  1
"""
WORD_2 = [1, -1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, 1]

"""
 1 -1  1
 1 -1  1
 1  1  1
-1 -1  1
-1 -1  1
"""
WORD_4 = [1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1]

"""
 1  1  1
 1 -1  1
 1  1  1
 1 -1  1
 1  1  1
"""
WORD_8 = [1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1]
```

### Рассчитанная матрица весов обратных связей
```
[[ 0  1  3  1  1  1 -3  3 -3  1  3  3  3  1  3]
 [ 1  0  1 -1 -1 -1 -1  1 -1 -1  1  1  1  3  1]
 [ 3  1  0  1  1  1 -3  3 -3  1  3  3  3  1  3]
 [ 1 -1  1  0  3  3 -1  1 -1  3  1  1  1 -1  1]
 [ 1 -1  1  3  0  3 -1  1 -1  3  1  1  1 -1  1]
 [ 1 -1  1  3  3  0 -1  1 -1  3  1  1  1 -1  1]
 [-3 -1 -3 -1 -1 -1  0 -3  3 -1 -3 -3 -3 -1 -3]
 [ 3  1  3  1  1  1 -3  0 -3  1  3  3  3  1  3]
 [-3 -1 -3 -1 -1 -1  3 -3  0 -1 -3 -3 -3 -1 -3]
 [ 1 -1  1  3  3  3 -1  1 -1  0  1  1  1 -1  1]
 [ 3  1  3  1  1  1 -3  3 -3  1  0  3  3  1  3]
 [ 3  1  3  1  1  1 -3  3 -3  1  3  0  3  1  3]
 [ 3  1  3  1  1  1 -3  3 -3  1  3  3  0  1  3]
 [ 1  3  1 -1 -1 -1 -1  1 -1 -1  1  1  1  0  1]
 [ 3  1  3  1  1  1 -3  3 -3  1  3  3  3  1  0]]
```

### Результаты тестирования
- 8  
```python
[1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1] # Эталон
[1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1] # Результат
```

- Искаженная 8
```python
ERROR_WORD_8 = [-1, 1, 1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1]

[1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1] # Эталон
[1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1] # Результат
```

### Исходный код
- [Точка входа](/app/main.py)
- [Класс с обучением](/app/neural.py)

#### main.py
```python
from neural import NetworkHopfield

"""
 1  1  1
-1 -1  1
 1  1  1
 1 -1 -1
 1  1  1
"""
WORD_2 = [1, -1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, 1]

"""
 1 -1  1
 1 -1  1
 1  1  1
-1 -1  1
-1 -1  1
"""
WORD_4 = [1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1]

"""
 1  1  1
 1 -1  1
 1  1  1
 1 -1  1
 1  1  1
"""
WORD_8 = [1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1]

ERROR_WORD_8 = [-1, 1, 1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1]

if __name__ == "__main__":
    network = NetworkHopfield(WORD_2, WORD_4, WORD_8)

    print(network.get_result(WORD_8))
    print(network.get_result(ERROR_WORD_8))
```

#### neural.py
```python
import numpy as np


class NetworkHopfield:
    words = []
    weights = []
    y_n_1 = []

    def __init__(self, first, second, third):
        self.words = [first, second, third]
        self.init()

    def init(self):
        self.weights = sum([np.dot(np.array([word]).transpose(), np.array([word])) for word in self.words])
        for i in range(len(self.weights)):
            self.weights[i][i] = 0

        self.y_n_1 = []

    def net_count(self):
        result = []
        for i in range(len(self.y_n_1)):
            result.append(sum([self.weights[j][i] * self.y_n_1[j] for j in range(len(self.y_n_1))]))

        return result

    def out_function(self, net):
        out = []
        for i in range(len(self.y_n_1)):
            if net[i] > 0:
                current = 1
            elif net[i] < 0:
                current = -1
            else:
                current = self.y_n_1[i]
            out.append(current)

        return out

    def get_result(self, data):
        self.y_n_1 = data
        return self.out_function(self.net_count())
```

### Выполнял
Перескоков Владислав Андреевич,   
МГТУ им. Баумана,  
ИУ-8, 3 курс, 61 группа,  
Вариант 13  
